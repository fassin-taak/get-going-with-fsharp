<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="3">
            <Title>An Introduction to F#</Title>
            <Text>F# is a functional-first programming language. That is, F# is a programming language which emphasizes the functional aspect of programming to a greater extent than other languages you may be familiar with such as C#, Visual Basic .NET, Python and JavaScript. You will already be quite familiar with functions: you met them in high school when you drew a plot of the function, ￼ using your trusty Sharp EL 9300 graphing calculator or your favorite plotting program on the WWW (e.g. Desmos at https://desmos.com/calculator). Functions as opposed to objects are the first-class citizens of functional programming languages like F#. They allow one to think about and solve problems using features prominent in functional programming such as immutability, pipelining, partial application, type-inference, and strong typing. (Note that these features are not unique to F#, they exist in other functional programming languages, and indeed in ordinary imperative programming languages such as C#, Visual Basic .NET, Python and JavaScript).
F# was created by Don Syme who is an Australian Computer Scientist and Principal Researcher at Microsoft Research, Cambridge, UK. He is still very active in the F# community and makes contributions to the F# language to this day (March 24th 2021). You could call him the Grandfather of F# or the Supreme Leader of the F# community.
F# allows one to think about a particular programming problem or task in a clean and simple way. It has the clean simplicity of Python while retaining the performance and type safety found in languages such as C++ and C#. F# can be used to write small programs with specific goals set at the start to large systems with open-ended goals.
F# is fully open source and fully cross-platform. F# is integrated within Visual Studio and so can make full use of all the integrated development environment’s (IDE’s) features such as Intellisense, packages management, documentation browser, etc. Alternatively, The Visual F# Tools can be downloaded from https://github.com/Microsoft/visualfsharp to developer F# programs without an IDE. On top of that F# code can be run in Jupyter Notebooks hosted on Microsoft Azure Services.
I also use Visual Studio Code sometimes because it is cross-platform and has about a million different extensions from Markdown edting support to copy code/text with line numbers and everything else you can think of in-between.






</Text>
        </Document>
        <Document ID="4">
            <Title>Hello, World!</Title>
            <Text>As is traditional when learning most programming languages we will begin by writing a “Hello, World!” program. To do so first download and install the .NET SDK. You search the Internet for instructions how to download and install the .NET SDK. You are also free to choose whichever OS you desire.
Open a command terminal and type in

dotnet new console -lang &quot;F#&quot; -o hello

cd into the directory hello which was created when you typed in the above command. Then, open the file Program.fs which was created when the directory was created. It should look something like:

     01: // Learn more about F# at http://docs.microsoft.com/dotnet/fsharp
02: 
03: open System
04: 
05: // Define a function to construct a message to print
06: let from whom =
07:     sprintf &quot;from %s&quot; whom
08: 
09: [&lt;EntryPoint&gt;]
10: let main argv =
11:     let message = from &quot;F#&quot; // Call the function
12:     printfn &quot;Hello world %s&quot; message
13:     0 // return an integer exit code

Replace the contents of the file with:

1: printfn &quot;Hello, World!&quot;

Now go back to the terminal and type in:

dotnet run

Pretty cool! Right? One line of code is all that's needed to print out a message to the console and a one line command is all you need to build and run the executable that prints out the message. That's a lot better than C or C++ and just as good as Python or any other scripting language.



</Text>
        </Document>
        <Document ID="5">
            <Title>Compiler Codes</Title>
            <Text>Codes for compiler - Literature and Latte

￼User avatar
Cosmicjive
Posts: 53
Joined: Wed Sep 22, 2010 8:14 pm
Platform: Mac + Windows
Location: Tustin, CA (USA)
QUOTE
MON MAR 19, 2012 6:32 PM POST
These are known as &quot;placeholder tags.&quot;

These are the tags that work in the Windows version of the application:

Statistics

&lt;$wc&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled.

&lt;$wc50&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 50 words.

&lt;$wc100&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 100 words.

&lt;$wc500&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 500 words.

&lt;$wc1000&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 1000 words.

&lt;$cc&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled.

&lt;$cc50&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 50 characters.

&lt;$cc100&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 100 characters.

&lt;$cc500&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 500 characters.

&lt;$cc1000&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 1000 characters.




Auto-Numbering

&lt;$n&gt;
Gets replaced with Arabic numerals during the Compile process. The number is incremented each time a &lt;$n&gt; tag is encountered in the text, so “&lt;$n&gt;, &lt;$n&gt;, &lt;$n&gt;” would become “1, 2, 3” in the compiled text.

&lt;$sn&gt;
The same as &lt;$n&gt; but intended to be used for sub-numbering. The count restarts each time an &lt;$n&gt; tag is encountered. Thus, “&lt;$n&gt; (&lt;$sn&gt;, &lt;$sn&gt;), &lt;$n&gt; (&lt;$sn&gt;, &lt;$sn&gt;)” would become “1 (1, 2), 2 (1, 2)” in the compiled text.

&lt;$r&gt;
Gets replaced with lowercase Roman numerals during the Compile process. The number is incremented each time a &lt;$r&gt; tag is encountered in the text, so “&lt;$r&gt;, &lt;$r&gt;, &lt;$r&gt;” would become “i, ii, iii” in the compiled text.

&lt;$R&gt;
Gets replaced with uppercase Roman numerals during the Compile process. The number is incremented each time a &lt;$R&gt; tag is encountered in the text, so “&lt;$R&gt;, &lt;$R&gt;, &lt;$R&gt;” would become “I, II, III” in the compiled text.

&lt;$w&gt;
Gets replaced with numbers as lowercase words (using the current language settings) during the Compile process. The number is incremented each time a &lt;$w&gt; tag is encountered in the text, so “&lt;$w&gt;, &lt;$w&gt;, &lt;$w&gt;” would become “one, two, three” in the compiled text.

&lt;$t&gt;
Gets replaced with numbers as title-case words (using the current language settings) during the Compile process. The number is incremented each time a &lt;$t&gt; tag is encountered in the text, so “&lt;$t&gt;, &lt;$t&gt;, &lt;$t&gt;” would become “One, Two, Three” in the compiled text.

&lt;$W&gt;
Gets replaced with numbers as uppercase words (using the current language settings) during the Compile process. The number is incremented each time a &lt;$W&gt; tag is encountered in the text, so “&lt;$W&gt;, &lt;$W&gt;, &lt;$W&gt;” would become “ONE, TWO, THREE” in the compiled text.

&lt;$hn&gt;
Gets replaced during the Compile process with hierarchical numbering based on the level of the document in which the tag occurs relative to the Draft folder or compile group (depending on the current compile settings). So occurrences of the &lt;$hn&gt; tag in the second document in the Draft folder may get replaced with the number “2”; occurrences of the tag in the third subdocument of the eight document in the Draft folder may be replaced with “8.3”.

Restarting auto-numbering streams:
&lt;$rst&gt;
Place &lt;$rst&gt; immediately before any of the auto-numbering tags to restart the numbering. So, for instance, “&lt;$w&gt;, &lt;$w&gt;, &lt;$w&gt;, &lt;$rst&gt;&lt;$w&gt;, &lt;$w&gt;” would become “one, two, three, one, two” in the compiled text.

Page Numbers

&lt;$p&gt;
When used in the header or footer, gets replaced with the current page number.


-Jeff</Text>
        </Document>
        <Document ID="6">
            <Title>Summary</Title>
            <Text>In this chapter your wrote your first F# program!: A simple &quot;Hello, World!&quot; program. To do this you setup your system to write F# programs. You downloaded and installed the .NET SDK (if you didn't already have it installed) and then created a new console project. You then modified the code to print &quot;Hello, World!&quot; to the console.
You then took a tour of F# from around the web and returned to the book to complete some simple exercises. You also read some documentation on the dotnet command and played around with the command a little. You could say you are a beginner F# programmer, maybe even an intermediate F# programmer who is fairly competent at thinking about problems in a functional way. You are ready now to tackle what every programmer dreads and loves at the same time: UIs!</Text>
        </Document>
        <Document ID="7">
            <Title>The dotnet Command</Title>
            <Text>You should also familiarize yourself with the dotnet command as you will be using it a lot. You can get help by typing in dotnet -h and also by searching and reading the Microsoft documentation online. Here are a few exercises that you can try after you've familiarized yourself with the dotnet command.</Text>
        </Document>
        <Document ID="8">
            <Title>Exercises</Title>
            <Text>What is the default build configuration?
In which directory is the output stored?
What (SDK) command do you need to use to clean the output inside the build directory? Which files/directories still remain after you've cleaned the build directory?
What command do you need to type in to build a Release version of the &quot;Hello, World!&quot; application?
How do you run the Release version of the application.
How do you clean the Release build?</Text>
        </Document>
        <Document ID="9">
            <Title>But Wait!</Title>
            <Text>I know what you're thinking!: There is something wrong here! Where is the function? There is a printfn function being called here which is taking a single string parameter as input and then outputting that string parameter to the console. But where is our function? Isn't F# supposed to be a functional-first programming language where nearly everything is a function? That is true. But in this case to make things easier to do like simple scripting, the F# compiler is creating a &quot;main&quot; function for us which is then called by the .NET runtime. To make this more explicit we can wrap the &quot;Hello, World&quot; code inside of a function ourselves. So let's do that.
Change the code to the following:

1: open System
2: 
3: [&lt;EntryPoint&gt;]
4: let main(argv) =
5:   printfn &quot;Hello, World!&quot;
6:   0

Type in dotnet run to check that everything still works fine.
The code should be self-explanatory. Line 1 &quot;open&quot;s and makes the classes and objects in the .NET System library available for use by our little program. Line 3 sets the entry point for our program. Line 4 defines our function which takes in a string argument list as its one and only parameter. This parameter is not used in our program. Line 5 prints our &quot;Hello, World!&quot; message and finally line 6 returns the exit value. Notice that on line 6 we don't need to write &quot;return 0&quot; as in some other languages that you may be familiar with. You just write down the actual return value and that's it!</Text>
        </Document>
        <Document ID="10">
            <Title>Take a Tour of F#</Title>
            <Text>Now that you've written and run &quot;Hello, World!&quot; in F# you should take a tour of F#. Start at the following URL http://docs.microsoft.com/en-us/dotnet/fsharp/tour. Once you feel ready to continue reading this book come back here and do the exercises in the following section.</Text>
        </Document>
        <Document ID="11">
            <Title>Exercises</Title>
            <Text>Modify the &quot;Hello, World!&quot; program to ask the user for his/her name and print out &quot;Hello &lt;name of user&gt;!&quot; instead of &quot;Hello, World!&quot;.
Write a function which will take two numbers and add them together and return answer.
Write a function which will compute the factorial of a number. You will need to research how to write recursive functions in F#.
Write a function which will compute the nth term in the Fibonacci sequence.</Text>
        </Document>
        <Document ID="12">
            <Title>What Next?</Title>
            <Text>By now you should have a fairly good grasp of functional programming and F# in particular. You could stop reading this book now and continue your exploration of F# as needed for the particular set of projects that you are working on.
So what value does this book on F# have? Well, read on and you can decide for yourself whether the book fulfills any purpose and hence has any value. The remainder of this book contains mini-projects on various interesting topics from UIs to Neural Networks to 3D Computer Graphics. Each of the projects was chosen to illustrate how to solve a particular type of problem with F#. In the next chapter we will tackle the problem of writing UIs with F#. By the end of the chapter we wil have a fairly functional fractal image generator for Julia and Mandlebrot sets. So without further delay let's get started!</Text>
        </Document>
        <Document ID="13">
            <Title>Writing UIs with F#</Title>
            <Text>There are a number of paths available to programmers who decide to write UIs with F#:

Avalonia.FuncUI (Cross-Platform)
Elmish.WPF (Windows Only)
Use Windows Forms or WPF directly (Windows Only)

We will take the option 1, the Avalonia.FuncUI route since it is cross-platform. Avalonia.FuncUI is fairly intuitive to use and will suit our purposes admirably. If you want, you can explore the alternatives starting at http://fsharp.org/use/desktop-apps/.
First read a little on how to get started with Avalonia.FuncUI at the following URL:

https://avaloniacommunity.github.io/Avalonia.FuncUI.Docs/

Install Avalonia.FuncUI and then afterwards create a new &quot;Basic Template&quot; project. Check to make sure everything compiles and runs smoothly. A description of the files created in the &quot;Basic Template&quot; project is at the URL:

https://avaloniacommunity.github.io/Avalonia.FuncUI.Docs/guides/Basic-Template.html

Modify the title of the MainWindow class to &quot;Fractals&quot; and then change the width and height of the window to 500 and 500 respectively. Next modify Counter.fs to display a window like the one shown in the figure below:

￼

If you get stuck, or want to check your code against mine here is what I wrote:

01: namespace Fractals
02: 
03: module Counter =
04:     open Avalonia.Controls
05:     open Avalonia.FuncUI.DSL
06:     open Avalonia.Layout
07:     
08:     /// The fractal type.
09:     type FractalType = Julia | Mandelbrot
10: 
11:     /// The state.
12:     type State = { ft : FractalType }
13: 
14:     /// Initializes the fractal type.
15:     let Init = { ft = Julia }
16: 
17:     /// Updates the fractal type.
18:     let Update (msg: FractalType) (state: State) : State =
19:       match msg with
20:       | Julia -&gt; { state with ft = Julia }
21:       | Mandelbrot -&gt; { state with ft = Mandelbrot }
22: 
23:     
24:     let View (state: State) (dispatch) =
25:         DockPanel.create [
26:             DockPanel.children [
27:                 DockPanel.create [
28:                     DockPanel.children [
29:                         Button.create [
30:                             Button.dock Dock.Top
31:                             Button.height 250.0
32:                             Button.onClick (fun _ -&gt; dispatch Julia)
33:                             Button.content &quot;Julia&quot;
34:                         ]                
35:                         Button.create [
36:                             Button.dock Dock.Bottom
37:                             Button.height 250.0
38:                             Button.onClick (fun _ -&gt; dispatch Mandelbrot)
39:                             Button.content &quot;Mandel&quot;
40:                         ]
41:                     ]
42:                 ]
43:                 TextBlock.create [
44:                     TextBlock.dock Dock.Right
45:                     TextBlock.fontSize 48.0
46:                     TextBlock.verticalAlignment VerticalAlignment.Center
47:                     TextBlock.horizontalAlignment HorizontalAlignment.Center
48:                     TextBlock.text (string state.ft)
49:                 ]
50:             ]
51:         ]

If you've written your code correctly here is what should happen when you start Fractals.

A window should pop up like the one in figure 1.
Pressing the &quot;Mandel&quot; button should change the text in the TextBlock to &quot;Mandelbrot&quot;.
Pressing the &quot;Julia&quot; button should change the text in the TextBlock to &quot;Julia&quot;.

If something doesn't work as expected then check your code carefully for any mistakes and compare your code with mine if necessary.
Everything working correctly then? Great! Let's continue then.</Text>
        </Document>
    </Documents>
</SearchIndexes>
