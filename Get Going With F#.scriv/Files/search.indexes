<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="3">
            <Title>An Introduction to F#</Title>
            <Text>F# is a functional-first programming language. That is, F# is a programming language which emphasizes the functional aspect of programming to a greater extent than other languages you may be familiar with such as C#, Visual Basic .NET, Python and JavaScript. You will already be quite familiar with functions: you met them in high school when you drew a plot of the function, ￼ using your trusty Sharp EL 9300 graphing calculator or your favorite plotting program on the WWW (e.g. Desmos at https://desmos.com/calculator). Functions as opposed to objects are the first-class citizens of functional programming languages like F#. They allow one to think about and solve problems using features prominent in functional programming such as immutability, pipelining, partial application, type-inference, and strong typing. (Note that these features are not unique to F#, they exist in other functional programming languages, and indeed in ordinary imperative programming languages such as C#, Visual Basic .NET, Python and JavaScript).
F# was created by Don Syme who is an Australian Computer Scientist and Principal Researcher at Microsoft Research, Cambridge, UK. He is still very active in the F# community and makes contributions to the F# language to this day (March 24th 2021). You could call him the Grandfather of F# or the Supreme Leader of the F# community.
F# allows one to think about a particular programming problem or task in a clean and simple way. It has the clean simplicity of Python while retaining the performance and type safety found in languages such as C++ and C#. F# can be used to write small programs with specific goals set at the start to large systems with open-ended goals.
F# is fully open source and fully cross-platform. F# is integrated within Visual Studio and so can make full use of all the integrated development environment’s (IDE’s) features such as Intellisense, packages management, documentation browser, etc. Alternatively, The Visual F# Tools can be downloaded from https://github.com/Microsoft/visualfsharp to developer F# programs without an IDE. On top of that F# code can be run in Jupyter Notebooks hosted on Microsoft Azure Services.
I also use Visual Studio Code sometimes because it is cross-platform and has about a million different extensions from Markdown edting support to copy code/text with line numbers and everything else you can think of in-between.






</Text>
        </Document>
        <Document ID="4">
            <Title>Hello, World!</Title>
            <Text>As is traditional when learning most programming languages we will begin by writing a “Hello, World!” program. To do so first download and install the .NET SDK. You search the Internet for instructions how to download and install the .NET SDK. You are also free to choose whichever OS you desire.
Open a command terminal and type in

dotnet new console -lang &quot;F#&quot; -o hello

cd into the directory hello which was created when you typed in the above command. Then, open the file Program.fs which was created when the directory was created. It should look something like:

// Learn more about F# at http://docs.microsoft.com/dotnet/fsharp

open System

// Define a function to construct a message to print
let from whom =
    sprintf &quot;from %s&quot; whom

[&lt;EntryPoint&gt;]
let main argv =
    let message = from &quot;F#&quot; // Call the function
    printfn &quot;Hello world %s&quot; message
    0 // return an integer exit code

Replace the contents of the file with just:

printfn &quot;Hello, World!&quot;

Now go back to the terminal and type in:

dotnet run

Pretty cool! Right? One line of code is all that's needed to print out a message to the console and a one line command is all you need to build and run the executable that prints out the message. That's a lot better than C or C++ and just as good as Python or any other scripting language.</Text>
        </Document>
        <Document ID="5">
            <Title>Compiler Codes</Title>
            <Text>Codes for compiler - Literature and Latte

￼User avatar
Cosmicjive
Posts: 53
Joined: Wed Sep 22, 2010 8:14 pm
Platform: Mac + Windows
Location: Tustin, CA (USA)
QUOTE
MON MAR 19, 2012 6:32 PM POST
These are known as &quot;placeholder tags.&quot;

These are the tags that work in the Windows version of the application:

Statistics

&lt;$wc&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled.

&lt;$wc50&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 50 words.

&lt;$wc100&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 100 words.

&lt;$wc500&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 500 words.

&lt;$wc1000&gt;
Gets replaced during the Compile process with the total word count of the text currently being compiled, rounded to the nearest 1000 words.

&lt;$cc&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled.

&lt;$cc50&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 50 characters.

&lt;$cc100&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 100 characters.

&lt;$cc500&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 500 characters.

&lt;$cc1000&gt;
Gets replaced during the Compile process with the total character count of the text currently being compiled, rounded to the nearest 1000 characters.




Auto-Numbering

&lt;$n&gt;
Gets replaced with Arabic numerals during the Compile process. The number is incremented each time a &lt;$n&gt; tag is encountered in the text, so “&lt;$n&gt;, &lt;$n&gt;, &lt;$n&gt;” would become “1, 2, 3” in the compiled text.

&lt;$sn&gt;
The same as &lt;$n&gt; but intended to be used for sub-numbering. The count restarts each time an &lt;$n&gt; tag is encountered. Thus, “&lt;$n&gt; (&lt;$sn&gt;, &lt;$sn&gt;), &lt;$n&gt; (&lt;$sn&gt;, &lt;$sn&gt;)” would become “1 (1, 2), 2 (1, 2)” in the compiled text.

&lt;$r&gt;
Gets replaced with lowercase Roman numerals during the Compile process. The number is incremented each time a &lt;$r&gt; tag is encountered in the text, so “&lt;$r&gt;, &lt;$r&gt;, &lt;$r&gt;” would become “i, ii, iii” in the compiled text.

&lt;$R&gt;
Gets replaced with uppercase Roman numerals during the Compile process. The number is incremented each time a &lt;$R&gt; tag is encountered in the text, so “&lt;$R&gt;, &lt;$R&gt;, &lt;$R&gt;” would become “I, II, III” in the compiled text.

&lt;$w&gt;
Gets replaced with numbers as lowercase words (using the current language settings) during the Compile process. The number is incremented each time a &lt;$w&gt; tag is encountered in the text, so “&lt;$w&gt;, &lt;$w&gt;, &lt;$w&gt;” would become “one, two, three” in the compiled text.

&lt;$t&gt;
Gets replaced with numbers as title-case words (using the current language settings) during the Compile process. The number is incremented each time a &lt;$t&gt; tag is encountered in the text, so “&lt;$t&gt;, &lt;$t&gt;, &lt;$t&gt;” would become “One, Two, Three” in the compiled text.

&lt;$W&gt;
Gets replaced with numbers as uppercase words (using the current language settings) during the Compile process. The number is incremented each time a &lt;$W&gt; tag is encountered in the text, so “&lt;$W&gt;, &lt;$W&gt;, &lt;$W&gt;” would become “ONE, TWO, THREE” in the compiled text.

&lt;$hn&gt;
Gets replaced during the Compile process with hierarchical numbering based on the level of the document in which the tag occurs relative to the Draft folder or compile group (depending on the current compile settings). So occurrences of the &lt;$hn&gt; tag in the second document in the Draft folder may get replaced with the number “2”; occurrences of the tag in the third subdocument of the eight document in the Draft folder may be replaced with “8.3”.

Restarting auto-numbering streams:
&lt;$rst&gt;
Place &lt;$rst&gt; immediately before any of the auto-numbering tags to restart the numbering. So, for instance, “&lt;$w&gt;, &lt;$w&gt;, &lt;$w&gt;, &lt;$rst&gt;&lt;$w&gt;, &lt;$w&gt;” would become “one, two, three, one, two” in the compiled text.

Page Numbers

&lt;$p&gt;
When used in the header or footer, gets replaced with the current page number.


-Jeff</Text>
        </Document>
        <Document ID="6">
            <Title>Summary</Title>
            <Text>In this chapter your wrote your first F# program!: A simple &quot;Hello, World!&quot; program. To do this you setup your system to write F# programs. You downloaded and installed the .NET SDK (if you didn't already have it installed) and then created a new console project. You then modified the code to print &quot;Hello, World!&quot; to the console.
You then took a tour of F# from around the web and returned to the book to complete some simple exercises. You also read some documentation on the dotnet command and played around with the command a little. You could say you are a beginner F# programmer, maybe even an intermediate F# programmer who is fairly competent at thinking about problems in a functional way. You are ready now to tackle what every programmer dreads and loves at the same time: UIs!
</Text>
        </Document>
        <Document ID="7">
            <Title>The dotnet Command</Title>
            <Text>You should also familiarize yourself with the dotnet command as you will be using it a lot. You can get help by typing in dotnet -h and also by searching and reading the Microsoft documentation online. Here are a few exercises that you can try after you've familiarized yourself with the dotnet command.</Text>
        </Document>
        <Document ID="8">
            <Title>Exercises</Title>
            <Text>What is the default build configuration?
In which directory is the output stored?
What (SDK) command do you need to use to clean the output inside the build directory? Which files/directories still remain after you've cleaned the build directory?
What command do you need to type in to build a Release version of the &quot;Hello, World!&quot; application?
How do you run the Release version of the application.
How do you clean the Release build?</Text>
        </Document>
        <Document ID="9">
            <Title>But Wait!</Title>
            <Text>I know what you're thinking!: There is something wrong here! Where is the function? There is a printfn function being called here which is taking a single string parameter as input and then outputting that string parameter to the console. But where is our function? Isn't F# supposed to be a functional-first programming language where nearly everything is a function? That is true. But in this case to make things easier to do like simple scripting, the F# compiler is creating a &quot;main&quot; function for us which is then called by the .NET runtime. To make this more explicit we can wrap the &quot;Hello, World&quot; code inside of a function ourselves. So let's do that.
Change the code to the following:

open System

[&lt;EntryPoint&gt;]
let main(argv) =
  printfn &quot;Hello, World!&quot;
  0

Type in dotnet run to check that everything still works fine.
The code should be self-explanatory. Line 1 &quot;open&quot;s and makes the classes and objects in the .NET System library available for use by our little program. Line 3 sets the entry point for our program. Line 4 defines our function which takes in a string argument list as its one and only parameter. This parameter is not used in our program. Line 5 prints our &quot;Hello, World!&quot; message and finally line 6 returns the exit value. Notice that on line 6 we don't need to write &quot;return 0&quot; as in some other languages that you may be familiar with. You just write down the actual return value and that's it!</Text>
        </Document>
        <Document ID="10">
            <Title>Take a Tour of F#</Title>
            <Text>Now that you've written and run &quot;Hello, World!&quot; in F# you should take a tour of F#. Start at the following URL http://docs.microsoft.com/en-us/dotnet/fsharp/tour. Once you feel ready to continue reading this book come back here and do the exercises in the following section.</Text>
        </Document>
        <Document ID="11">
            <Title>Exercises</Title>
            <Text>Modify the &quot;Hello, World!&quot; program to ask the user for his/her name and print out &quot;Hello &lt;name of user&gt;!&quot; instead of &quot;Hello, World!&quot;.
Write a function which will take two numbers and add them together and return answer.
Write a function which will compute the factorial of a number. You will need to research how to write recursive functions in F#.
Write a function which will compute the nth term in the Fibonacci sequence.</Text>
        </Document>
        <Document ID="12">
            <Title>What Next?</Title>
            <Text>By now you should have a fairly good grasp of functional programming and F# in particular. You could stop reading this book now and continue your exploration of F# as needed for the particular set of projects that you are working on.
So what value does this book on F# have? Well, read on and you can decide for yourself whether the book fulfills any purpose and hence has any value. The remainder of this book contains mini-projects on various interesting topics from UIs to Neural Networks to 3D Computer Graphics. Each of the projects was chosen to illustrate how to solve a particular type of problem with F#. In the next chapter we will tackle the problem of writing UIs with F#. By the end of the chapter we wil have a fairly functional fractal image generator for Julia and Mandlebrot sets. So without further delay let's get started!</Text>
        </Document>
        <Document ID="13">
            <Title>Writing UIs with F#</Title>
            <Text>There are a number of paths available to programmers who decide to write UIs with F#:

Avalonia.FuncUI (Cross-Platform)
Elmish.WPF (Windows Only)
Use Windows Forms or WPF directly (Windows Only)

We will take option 2, the Elmish.WPF route, even though it is Windows only because it is a battle-tested UI framework with excellent documentation. If you want to be cross-platform then option 1, Avalonia.FuncUI is fairly intuitive to use and will suit your purposes admirably but at the time of writing (March 26th 2021) the documentation is so-so. So unless you like searching the web for answers and asking questions on Stack Exchange I don't recommend this route. Instead wait for 6 months and come back to Avalonia.FuncUI if you still need to write UIs in F#, the documentation will have improved by then. Option 3 is also available for those who must use Windows Forms or WPF directly in their apps.
You can find out more information about the three options available at http://fsharp.org/use/desktop-apps/. Since we are going to be using Elmish.WPF read https://github.com/elmish/Elmish.WPF#getting-started-with-elmishwpf first and then come back here.
Let's take what we've learned so far to create our Fractals viewer using Elmish.WPF for our UI. Since we are going to be working in Windows in this chapter we will used Visual Studio Community Edition for our development. Visual Studio Community Edition is free and you can download and install it from https://visualstudio.microsoft.com/vs/community/. Install the F# tools when you install Visual Studio Community Edition. Take some time 
Type in the following commands to create the skeleton of the Fractals viewer project:

1: dotnet new sln -n Fractals
2: dotnet new classlib -lang &quot;F#&quot; -n Viewer
3: dotnet sln add Viewer/Viewer.fsproj

A quick explanation of what each line means: In line 1 we create a new Visual Studio solution file called Fractals. In line 2 we create a new F# based class library called Viewer. The files associated with this Viewer are stored in the sub-directory Viewer. Finally, on line 3 the Viewer class library is added to the solution.
Now open up Visual Studio and open the solution file you just created. Right-click on the Viewer project in the Solution Explorer:

￼

and select Edit Project File in the context menu that appears:

￼

Edit the first line of the project file so that it reads:

&lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&gt;

Next, add a reference to the Elmish.WPF package. The way you do this is by right-clicking on the Viewer &gt; Dependencies &gt; Packages tree item:

￼

and then selecting Manage NuGet Packages… from the context menu that appears.

￼

Then select the Browse tab and type in Elmish.WPF in the search box which appears below the Browse label.

￼

Press the black arrow pointing down next to the Elmish.WPF package:

￼

Finally, press the OK button on the conformation dialog which appears.




</Text>
        </Document>
        <Document ID="14">
            <Title>Displaying Images</Title>
        </Document>
        <Document ID="15">
            <Title>Links</Title>
            <Text>https://github.com/elmish/Elmish.WPF#getting-started-with-elmishwpf

https://visualstudio.microsoft.com/vs/community/</Text>
        </Document>
    </Documents>
</SearchIndexes>
