<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Elmish.WPF</name></assembly>
<members>
<member name="M:Elmish.WPF.Binding.twoWayValidate``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``3,System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation messages from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``3,System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation messages from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``3,System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOptValidate``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts between
   the optional source value and an unwrapped (possibly <c>null</c>) value
   on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation messages from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOpt``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value. The binding
   automatically converts between the optional source value and an
   unwrapped (possibly <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWayOpt``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value. The binding
   automatically converts between the optional source value and an
   unwrapped (possibly <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.twoWay``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>Creates a two-way binding.</summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelWin``4(Microsoft.FSharp.Core.FSharpFunc{``0,Elmish.WPF.WindowState{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``3},Microsoft.FSharp.Core.FSharpOption{``2},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Like <see cref="subModelOpt" />, but uses the <c>WindowState</c> wrapper
   to show/hide/close a new window that will have the specified bindings as
   its <c>DataContext</c>.

   You do not need to set the <c>DataContext</c> yourself (neither in code
   nor XAML).

   The window can only be closed/hidden by changing the return value of
   <paramref name="getState" />, and can not be directly closed by the
   user. External close attempts (the Close/X button, Alt+F4, or System
   Menu -> Close) will cause the message specified by
   <paramref name="onCloseRequested" /> to be dispatched. You should supply
   <paramref name="onCloseRequested" /> and react to this in a manner that
   will not confuse a user trying to close the window (e.g. by closing it,
   or displaying relevant feedback to the user.)
 </summary>
 <param name="getState">Gets the window state and a sub-model.</param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="getWindow">
   The function used to get and configure the window.
 </param>
 <param name="onCloseRequested">
   The message to be dispatched on external close attempts (the Close/X
   button, Alt+F4, or System Menu -> Close).
 </param>
 <param name="isModal">
   Specifies whether the window will be shown modally (using
   window.ShowDialog, blocking the rest of the app) or non-modally (using
   window.Show).
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelWin``4(Microsoft.FSharp.Core.FSharpFunc{``0,Elmish.WPF.WindowState{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},``3}},Microsoft.FSharp.Core.FSharpOption{``2},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Like <see cref="subModelOpt" />, but uses the <c>WindowState</c> wrapper
   to show/hide/close a new window that will have the specified bindings as
   its <c>DataContext</c>.

   You do not need to set the <c>DataContext</c> yourself (neither in code
   nor XAML).

   The window can only be closed/hidden by changing the return value of
   <paramref name="getState" />, and can not be directly closed by the
   user. External close attempts (the Close/X button, Alt+F4, or System
   Menu -> Close) will cause the message specified by
   <paramref name="onCloseRequested" /> to be dispatched. You should supply
   <paramref name="onCloseRequested" /> and react to this in a manner that
   will not confuse a user trying to close the window (e.g. by closing it,
   or displaying relevant feedback to the user.)
 </summary>
 <param name="getState">Gets the window state and a sub-model.</param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="getWindow">
   The function used to get and configure the window.
 </param>
 <param name="onCloseRequested">
   The message to be dispatched on external close attempts (the Close/X
   button, Alt+F4, or System Menu -> Close).
 </param>
 <param name="isModal">
   Specifies whether the window will be shown modally (using
   window.ShowDialog, blocking the rest of the app) or non-modally (using
   window.Show).
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelWin``5(Microsoft.FSharp.Core.FSharpFunc{``0,Elmish.WPF.WindowState{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``4},Microsoft.FSharp.Core.FSharpOption{``3},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Like <see cref="subModelOpt" />, but uses the <c>WindowState</c> wrapper
   to show/hide/close a new window that will have the specified bindings as
   its <c>DataContext</c>.

   You do not need to set the <c>DataContext</c> yourself (neither in code
   nor XAML).

   The window can only be closed/hidden by changing the return value of
   <paramref name="getState" />, and can not be directly closed by the
   user. External close attempts (the Close/X button, Alt+F4, or System
   Menu -> Close) will cause the message specified by
   <paramref name="onCloseRequested" /> to be dispatched. You should supply
   <paramref name="onCloseRequested" /> and react to this in a manner that
   will not confuse a user trying to close the window (e.g. by closing it,
   or displaying relevant feedback to the user.)
 </summary>
 <param name="getState">Gets the window state and a sub-model.</param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="getWindow">
   The function used to get and configure the window.
 </param>
 <param name="onCloseRequested">
   The message to be dispatched on external close attempts (the Close/X
   button, Alt+F4, or System Menu -> Close).
 </param>
 <param name="isModal">
   Specifies whether the window will be shown modally (using
   window.ShowDialog, blocking the rest of the app) or non-modally (using
   window.Show).
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelWin``5(Microsoft.FSharp.Core.FSharpFunc{``0,Elmish.WPF.WindowState{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.Unit},``4}},Microsoft.FSharp.Core.FSharpOption{``3},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Like <see cref="subModelOpt" />, but uses the <c>WindowState</c> wrapper
   to show/hide/close a new window that will have the specified bindings as
   its <c>DataContext</c>.

   You do not need to set the <c>DataContext</c> yourself (neither in code
   nor XAML).

   The window can only be closed/hidden by changing the return value of
   <paramref name="getState" />, and can not be directly closed by the
   user. External close attempts (the Close/X button, Alt+F4, or System
   Menu -> Close) will cause the message specified by
   <paramref name="onCloseRequested" /> to be dispatched. You should supply
   <paramref name="onCloseRequested" /> and react to this in a manner that
   will not confuse a user trying to close the window (e.g. by closing it,
   or displaying relevant feedback to the user.)
 </summary>
 <param name="getState">Gets the window state and a sub-model.</param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="getWindow">
   The function used to get and configure the window.
 </param>
 <param name="onCloseRequested">
   The message to be dispatched on external close attempts (the Close/X
   button, Alt+F4, or System Menu -> Close).
 </param>
 <param name="isModal">
   Specifies whether the window will be shown modally (using
   window.ShowDialog, blocking the rest of the app) or non-modally (using
   window.Show).
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelWin``6(Microsoft.FSharp.Core.FSharpFunc{``0,Elmish.WPF.WindowState{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``2,``3}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``5},Microsoft.FSharp.Core.FSharpOption{``4},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Like <see cref="subModelOpt" />, but uses the <c>WindowState</c> wrapper
   to show/hide/close a new window that will have the specified bindings as
   its <c>DataContext</c>.

   You do not need to set the <c>DataContext</c> yourself (neither in code
   nor XAML).

   The window can only be closed/hidden by changing the return value of
   <paramref name="getState" />, and can not be directly closed by the
   user. External close attempts (the Close/X button, Alt+F4, or System
   Menu -> Close) will cause the message specified by
   <paramref name="onCloseRequested" /> to be dispatched. You should supply
   <paramref name="onCloseRequested" /> and react to this in a manner that
   will not confuse a user trying to close the window (e.g. by closing it,
   or displaying relevant feedback to the user.)

   If you don't nead a sub-model, you can use
   <c>WindowState&lt;unit&gt;</c> to just control the Window visibility,
   and pass <c>fst</c> to <paramref name="toBindingModel" />.
 </summary>
 <param name="getState">Gets the window state and a sub-model.</param>
 <param name="toBindingModel">
   Converts the models to the model used by the bindings.
 </param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="getWindow">
   The function used to get and configure the window.
 </param>
 <param name="onCloseRequested">
   The message to be dispatched on external close attempts (the Close/X
   button, Alt+F4, or System Menu -> Close).
 </param>
 <param name="isModal">
   Specifies whether the window will be shown modally (using
   window.ShowDialog, blocking the rest of the app) or non-modally (using
   window.Show).
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelWin``6(Microsoft.FSharp.Core.FSharpFunc{``0,Elmish.WPF.WindowState{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``2,``3}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.Unit},``5}},Microsoft.FSharp.Core.FSharpOption{``4},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Like <see cref="subModelOpt" />, but uses the <c>WindowState</c> wrapper
   to show/hide/close a new window that will have the specified bindings as
   its <c>DataContext</c>.

   You do not need to set the <c>DataContext</c> yourself (neither in code
   nor XAML).

   The window can only be closed/hidden by changing the return value of
   <paramref name="getState" />, and can not be directly closed by the
   user. External close attempts (the Close/X button, Alt+F4, or System
   Menu -> Close) will cause the message specified by
   <paramref name="onCloseRequested" /> to be dispatched. You should supply
   <paramref name="onCloseRequested" /> and react to this in a manner that
   will not confuse a user trying to close the window (e.g. by closing it,
   or displaying relevant feedback to the user.)

   If you don't nead a sub-model, you can use
   <c>WindowState&lt;unit&gt;</c> to just control the Window visibility,
   and pass <c>fst</c> to <paramref name="toBindingModel" />.
 </summary>
 <param name="getState">Gets the window state and a sub-model.</param>
 <param name="toBindingModel">
   Converts the models to the model used by the bindings.
 </param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="getWindow">
   The function used to get and configure the window.
 </param>
 <param name="onCloseRequested">
   The message to be dispatched on external close attempts (the Close/X
   button, Alt+F4, or System Menu -> Close).
 </param>
 <param name="isModal">
   Specifies whether the window will be shown modally (using
   window.ShowDialog, blocking the rest of the app) or non-modally (using
   window.Show).
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelSeq``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``2},``4}}})">
 <summary>
   Creates a binding to a sequence of sub-models, each uniquely identified
   by the value returned by <paramref name="getId" />. The sub-models have
   their own bindings. You typically bind this to the <c>ItemsSource</c> of
   an
   <c>ItemsControl</c>, <c>ListView</c>, <c>TreeView</c>, etc.
 </summary>
 <param name="getSubModels">Gets the sub-models from the model.</param>
 <param name="getId">Gets a unique identifier for a sub-model.</param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
</member>
<member name="M:Elmish.WPF.Binding.subModelSeq``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``3,``4},``5},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``2},``4}}})">
 <summary>
   Creates a binding to a sequence of sub-models, each uniquely identified
   by the value returned by <paramref name="getId" />. The sub-models have
   their own bindings and message type. You typically bind this to the
   <c>ItemsSource</c> of an <c>ItemsControl</c>, <c>ListView</c>,
   <c>TreeView</c>, etc.
 </summary>
 <param name="getSubModels">Gets the sub-models from the model.</param>
 <param name="getId">Gets a unique identifier for a sub-model.</param>
 <param name="toMsg">
   Converts the sub-model ID and messages used in the bindings to parent
   model messages (e.g. a parent message union case that wraps the
   sub-model ID and message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
</member>
<member name="M:Elmish.WPF.Binding.subModelSeq``7(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``2},``3},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``4,``5},``6},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``3,``5}}})">
 <summary>
   Creates a binding to a sequence of sub-models, each uniquely identified
   by the value returned by <paramref name="getId" />. The sub-models have
   their own bindings and message type. You typically bind this to the
   <c>ItemsSource</c> of an <c>ItemsControl</c>, <c>ListView</c>,
   <c>TreeView</c>, etc.
 </summary>
 <param name="getSubModels">Gets the sub-models from the model.</param>
 <param name="toBindingModel">
   Converts the models to the model used by the bindings.
 </param>
 <param name="getId">Gets a unique identifier for a sub-model.</param>
 <param name="toMsg">
   Converts the sub-model ID and messages used in the bindings to parent
   model messages (e.g. a parent message union case that wraps the
   sub-model ID and message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
</member>
<member name="M:Elmish.WPF.Binding.subModelSelectedItem``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to a <c>SelectedItem</c>-like property where
   the
   <c>ItemsSource</c>-like property is a <see cref="subModelSeq" />
   binding. Automatically converts the dynamically created Elmish.WPF view
   models to/from their corresponding IDs, so the Elmish user code only has
   to work with the IDs.

   Only use this if you are unable to use some kind of <c>SelectedValue</c>
   or
   <c>SelectedIndex</c> property with a normal <see cref="twoWay" />
   binding. This binding is less type-safe. It will throw when initializing
   the bindings if <paramref name="subModelSeqBindingName" />
   does not correspond to a <see cref="subModelSeq" /> binding, and it will
   throw at runtime if if the inferred <c>'id</c> type does not match the
   actual ID type used in that binding.
 </summary>
 <param name="subModelSeqBindingName">
   The name of the <see cref="subModelSeq" /> binding used as the items
   source.
 </param>
 <param name="get">Gets the selected sub-model/sub-binding ID from the
 model.</param>
 <param name="set">
   Returns the message to dispatch on selections/de-selections.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelSelectedItem``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to a <c>SelectedItem</c>-like property where
   the
   <c>ItemsSource</c>-like property is a <see cref="subModelSeq" />
   binding. Automatically converts the dynamically created Elmish.WPF view
   models to/from their corresponding IDs, so the Elmish user code only has
   to work with the IDs.

   Only use this if you are unable to use some kind of <c>SelectedValue</c>
   or
   <c>SelectedIndex</c> property with a normal <see cref="twoWay" />
   binding. This binding is less type-safe. It will throw when initializing
   the bindings if <paramref name="subModelSeqBindingName" />
   does not correspond to a <see cref="subModelSeq" /> binding, and it will
   throw at runtime if if the inferred <c>'id</c> type does not match the
   actual ID type used in that binding.
 </summary>
 <param name="subModelSeqBindingName">
   The name of the <see cref="subModelSeq" /> binding used as the items
   source.
 </param>
 <param name="get">Gets the selected sub-model/sub-binding ID from the
 model.</param>
 <param name="set">
   Returns the message to dispatch on selections/de-selections.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelOpt``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings,
   and may not exist. If it does not exist, bindings to this model will
   return <c>null</c> unless <paramref name="sticky" /> is <c>true</c>, in
   which case the last non-<c>null</c> model will be returned. You
   typically bind this to the <c>DataContext</c> of a <c>UserControl</c> or
   similar.

   The 'sticky' part is useful if you want to e.g. animate away a
   <c>UserControl</c> when the model is missing, but don't want the data
   used by that control to be cleared once the animation starts. (The
   animation must be triggered using another binding since this will never
   return <c>null</c>.)
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="sticky">
   If <c>true</c>, when the model is missing, the last non-<c>null</c>
   model will be returned instead of <c>null</c>.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelOpt``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings,
   and may not exist. If it does not exist, bindings to this model will
   return <c>null</c> unless <paramref name="sticky" /> is <c>true</c>, in
   which case the last non-<c>null</c> model will be returned. You
   typically bind this to the <c>DataContext</c> of a <c>UserControl</c> or
   similar.

   The 'sticky' part is useful if you want to e.g. animate away a
   <c>UserControl</c> when the model is missing, but don't want the data
   used by that control to be cleared once the animation starts. (The
   animation must be triggered using another binding since this will never
   return <c>null</c>.)
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="sticky">
   If <c>true</c>, when the model is missing, the last non-<c>null</c>
   model will be returned instead of <c>null</c>.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelOpt``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings and
   message type, and may not exist. If it does not exist, bindings to this
   model will return <c>null</c> unless <paramref name="sticky" /> is
   <c>true</c>, in which case the last non-<c>null</c> model will be
   returned. You typically bind this to the <c>DataContext</c> of a
   <c>UserControl</c> or similar.

   The 'sticky' part is useful if you want to e.g. animate away a
   <c>UserControl</c> when the model is missing, but don't want the data
   used by that control to be cleared once the animation starts. (The
   animation must be triggered using another binding since this will never
   return <c>null</c>.)
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="sticky">
   If <c>true</c>, when the model is missing, the last non-<c>null</c>
   model will be returned instead of <c>null</c>.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelOpt``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings and
   message type, and may not exist. If it does not exist, bindings to this
   model will return <c>null</c> unless <paramref name="sticky" /> is
   <c>true</c>, in which case the last non-<c>null</c> model will be
   returned. You typically bind this to the <c>DataContext</c> of a
   <c>UserControl</c> or similar.

   The 'sticky' part is useful if you want to e.g. animate away a
   <c>UserControl</c> when the model is missing, but don't want the data
   used by that control to be cleared once the animation starts. (The
   animation must be triggered using another binding since this will never
   return <c>null</c>.)
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="sticky">
   If <c>true</c>, when the model is missing, the last non-<c>null</c>
   model will be returned instead of <c>null</c>.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelOpt``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``2,``3}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings and
   message type, and may not exist. If it does not exist, bindings to this
   model will return <c>null</c> unless <paramref name="sticky" /> is
   <c>true</c>, in which case the last non-<c>null</c> model will be
   returned. You typically bind this to the <c>DataContext</c> of a
   <c>UserControl</c> or similar.

   The 'sticky' part is useful if you want to e.g. animate away a
   <c>UserControl</c> when the model is missing, but don't want the data
   used by that control to be cleared once the animation starts. (The
   animation must be triggered using another binding since this will never
   return <c>null</c>.)
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="toBindingModel">
   Converts the models to the model used by the bindings.
 </param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="sticky">
   If <c>true</c>, when the model is missing, the last non-<c>null</c>
   model will be returned instead of <c>null</c>.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModelOpt``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``2,``3}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings and
   message type, and may not exist. If it does not exist, bindings to this
   model will return <c>null</c> unless <paramref name="sticky" /> is
   <c>true</c>, in which case the last non-<c>null</c> model will be
   returned. You typically bind this to the <c>DataContext</c> of a
   <c>UserControl</c> or similar.

   The 'sticky' part is useful if you want to e.g. animate away a
   <c>UserControl</c> when the model is missing, but don't want the data
   used by that control to be cleared once the animation starts. (The
   animation must be triggered using another binding since this will never
   return <c>null</c>.)
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="toBindingModel">
   Converts the models to the model used by the bindings.
 </param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
 <param name="sticky">
   If <c>true</c>, when the model is missing, the last non-<c>null</c>
   model will be returned instead of <c>null</c>.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.subModel``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings.
   You typically bind this to the <c>DataContext</c> of a
   <c>UserControl</c> or similar.
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
</member>
<member name="M:Elmish.WPF.Binding.subModel``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{System.Tuple{``0,``1},``2}}})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings and
   message type. You typically bind this to the <c>DataContext</c> of a
   <c>UserControl</c> or similar.
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
</member>
<member name="M:Elmish.WPF.Binding.subModel``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``2,``3}}})">
 <summary>
   Creates a binding to a sub-model/component that has its own bindings and
   message type. You typically bind this to the <c>DataContext</c> of a
   <c>UserControl</c> or similar.
 </summary>
 <param name="getSubModel">Gets the sub-model from the model.</param>
 <param name="toBindingModel">
   Converts the models to the model used by the bindings.
 </param>
 <param name="toMsg">
   Converts the messages used in the bindings to parent model messages
   (e.g. a parent message union case that wraps the child message type).
 </param>
 <param name="bindings">Returns the bindings for the sub-model.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWaySeqLazy``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``3,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``3,``4})">
 <summary>
   Creates a one-way binding to a sequence of items, each uniquely
   identified by the value returned by <paramref name="getId"/>. The
   binding will only be updated if the output of <paramref name="get" />
   changes, as determined by <paramref name="equals" />. The binding is
   backed by a persistent
   <c>ObservableCollection</c>, so only changed items (as determined by
   <paramref name="itemEquals" />) will be replaced. If the items are
   complex and you want them updated instead of replaced, consider using
   <see cref="subModelSeq" />.
 </summary>
 <param name="get">Gets the intermediate value from the model.</param>
 <param name="equals">
   Indicates whether two intermediate values are equal. Good candidates are
   <c>elmEq</c> and <c>refEq</c>.
 </param>
 <param name="map">Transforms the value into the final collection.</param>
 <param name="itemEquals">
   Indicates whether two collection items are equal. Good candidates are
   <c>elmEq</c>, <c>refEq</c>, or simply <c>(=)</c>.
 </param>
 <param name="getId">Gets a unique identifier for a collection
 item.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWaySeq``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``2,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
 <summary>
   Creates a one-way binding to a sequence of items, each uniquely
   identified by the value returned by <paramref name="getId"/>. The
   binding is backed by a persistent <c>ObservableCollection</c>, so only
   changed items (as determined by <paramref name="itemEquals" />) will be
   replaced. If the items are complex and you want them updated instead of
   replaced, consider using <see cref="subModelSeq" />.
 </summary>
 <param name="get">Gets the collection from the model.</param>
 <param name="itemEquals">
   Indicates whether two collection items are equal. Good candidates are
   <c>elmEq</c>, <c>refEq</c>, or simply <c>(=)</c>.
 </param>
 <param name="getId">Gets a unique identifier for a collection
 item.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWayOptLazy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpValueOption{``2}})">
 <summary>
   Creates a lazily evaluated one-way binding to an optional value. The
   binding automatically converts between the optional source value and an
   unwrapped (possibly <c>null</c>) value on the view side. <paramref
   name="map" /> will be called only when the output of <paramref
   name="get" /> changes, as determined by <paramref name="equals" />.

   This may have better performance than a non-lazy binding for expensive
   computations (but may be less performant for non-expensive functions due
   to additional overhead).
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="equals">
   Indicates whether two intermediate values are equal. Good candidates are
   <c>elmEq</c> and <c>refEq</c>.
 </param>
 <param name="map">Transforms the intermediate value into the final
 type.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWayOptLazy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}})">
 <summary>
   Creates a lazily evaluated one-way binding to an optional value. The
   binding automatically converts between the optional source value and an
   unwrapped (possibly <c>null</c>) value on the view side. <paramref
   name="map" /> will be called only when the output of <paramref
   name="get" /> changes, as determined by <paramref name="equals" />.

   This may have better performance than a non-lazy binding for expensive
   computations (but may be less performant for non-expensive functions due
   to additional overhead).
 </summary>
 <param name="get">Gets the intermediate value from the model.</param>
 <param name="equals">
   Indicates whether two intermediate values are equal. Good candidates are
   <c>elmEq</c> and <c>refEq</c>.
 </param>
 <param name="map">Transforms the intermediate value into the final
 type.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWayOpt``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}})">
 <summary>
   Creates a one-way binding to an optional value. The binding
   automatically converts between the optional source value and an
   unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWayOpt``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
 <summary>
   Creates a one-way binding to an optional value. The binding
   automatically converts between the optional source value and an
   unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWayLazy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Core.FSharpFunc{``1,``2})">
 <summary>
   Creates a lazily evaluated one-way binding. <paramref name="map" />
   will be called only when the output of <paramref name="get" /> changes,
   as determined by <paramref name="equals" />. This may have better
   performance than <see cref="oneWay" /> for expensive computations (but
   may be less performant for non-expensive functions due to additional
   overhead).
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="equals">
   Indicates whether two intermediate values are equal. Good candidates are
   <c>elmEq</c> and <c>refEq</c>.
 </param>
 <param name="map">Transforms the value into the final type.</param>
</member>
<member name="M:Elmish.WPF.Binding.oneWay``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
 <summary>Creates a one-way binding.</summary>
 <param name="get">Gets the value from the model.</param>
</member>
<member name="M:Elmish.WPF.Binding.cmdParamIf``3(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``1,``2}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="exec" /> returns <c>Ok</c>.

   This overload allows more easily re-using the same validation functions
   for inputs and commands.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdParamIf``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="exec" /> returns <c>Some</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdParamIf``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="exec" /> returns <c>ValueSome</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdParamIf``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="canExec" /> returns <c>true</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="canExec">Indicates whether the command can execute.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdParam``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can always execute.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdIf``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``1,``2}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends only on the
   model (not the <c>CommandParameter</c>) and can execute if <paramref
   name="exec" />
   returns <c>Ok</c>.

   This overload allows more easily re-using the same validation functions
   for inputs and commands.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdIf``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends only on the
   model (not the <c>CommandParameter</c>) and can execute if <paramref
   name="exec" />
   returns <c>Some</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdIf``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends only on the
   model (not the <c>CommandParameter</c>) and can execute if <paramref
   name="exec" />
   returns <c>ValueSome</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmdIf``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends only on the
   model (not the <c>CommandParameter</c>) and can execute if <paramref
   name="canExec" />
   returns <c>true</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="canExec">Indicates whether the command can execute.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Binding.cmd``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a <c>Command</c> binding that depends only on the model (not the
   <c>CommandParameter</c>) and can always execute.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="T:Elmish.WPF.Binding`2">
<summary>
 Represents all necessary data used to create a binding.
</summary>
</member>
<member name="T:Elmish.WPF.BindingData`2">
<summary>
 Represents all necessary data used to create the different binding types.
</summary>
</member>
<member name="F:Elmish.WPF.ViewModel`2.errorsByBindingName">
<summary>
 Error messages keyed by property name.
</summary>
</member>
<member name="T:Elmish.WPF.VmBinding`2">
<summary>
 Represents all necessary data used in an active binding.
</summary>
</member>
<member name="M:Elmish.WPF.InternalUtils.buildUntypedGetter(System.Reflection.PropertyInfo)">
<summary>
 Returns a fast, untyped getter for the property specified by the PropertyInfo.
 The getter takes an instance and returns a property value.
</summary>
</member>
<member name="M:Elmish.WPF.InternalUtils.Patterns.|Kvp|``2(System.Collections.Generic.KeyValuePair{``0,``1})">
<summary>
 Deconstructs a KeyValuePair into a tuple.
</summary>
</member>
<member name="T:Elmish.WPF.InternalTypes.Command">
<summary>
 A command that optionally hooks into CommandManager.RequerySuggested to
 automatically trigger CanExecuteChanged whenever the CommandManager detects
 conditions that might change the output of canExecute. It&apos;s necessary to use
 this feature for command bindings where the CommandParameter is bound to
 another UI control (e.g. a ListView.SelectedItem).
</summary>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.subModelSelectedItem.Static``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to a <c>SelectedItem</c>-like property where
   the
   <c>ItemsSource</c>-like property is a <see cref="subModelSeq" />
   binding. Automatically converts the dynamically created Elmish.WPF
   view models to/from their corresponding IDs, so the Elmish user code
   only has to work with the IDs.

   Only use this if you are unable to use some kind of
   <c>SelectedValue</c> or
   <c>SelectedIndex</c> property with a normal <see cref="twoWay" />
   binding. This binding is less type-safe. It will throw when
   initializing the bindings if <paramref name="subModelSeqBindingName"
   />
   does not correspond to a <see cref="subModelSeq" /> binding, and it
   will throw at runtime if if the inferred <c>'id</c> type does not
   match the actual ID type used in that binding.
 </summary>
 <param name="subModelSeqBindingName">
   The name of the <see cref="subModelSeq" /> binding used as the items
   source.
 </param>
 <param name="get">Gets the selected sub-model/sub-binding ID from the
 model.</param>
 <param name="set">
   Returns the message to dispatch on selections/de-selections.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.subModelSelectedItem.Static``3(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to a <c>SelectedItem</c>-like property where
   the
   <c>ItemsSource</c>-like property is a <see cref="subModelSeq" />
   binding. Automatically converts the dynamically created Elmish.WPF
   view models to/from their corresponding IDs, so the Elmish user code
   only has to work with the IDs.

   Only use this if you are unable to use some kind of
   <c>SelectedValue</c> or
   <c>SelectedIndex</c> property with a normal <see cref="twoWay" />
   binding. This binding is less type-safe. It will throw when
   initializing the bindings if <paramref name="subModelSeqBindingName"
   />
   does not correspond to a <see cref="subModelSeq" /> binding, and it
   will throw at runtime if if the inferred <c>'id</c> type does not
   match the actual ID type used in that binding.
 </summary>
 <param name="subModelSeqBindingName">
   The name of the <see cref="subModelSeq" /> binding used as the items
   source.
 </param>
 <param name="get">Gets the selected sub-model/sub-binding ID from the
 model.</param>
 <param name="set">
   Returns the message to dispatch on selections/de-selections.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.cmdParamIf.Static``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,``0},Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="canExec" /> returns <c>true</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="canExec">Indicates whether the command can execute.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.cmdParamIf.Static``3(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpResult{``0,``1}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="exec" /> returns <c>Ok</c>.

   This overload allows more easily re-using the same validation
   functions for inputs and commands.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.cmdParamIf.Static``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="exec" /> returns <c>Some</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.cmdParamIf.Static``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpValueOption{``0}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a conditional <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can execute if <paramref name="exec" /> returns <c>ValueSome</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="uiBoundCmdParam">
   If <c>true</c>, <c>CanExecuteChanged</c> will trigger every time WPF's
   <c>CommandManager</c>
   detects UI changes that could potentially influence the command's
   ability to execute. This will likely lead to many more triggers than
   necessary, but is needed if you have bound the <c>CommandParameter</c>
   to another UI property.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.cmdParam.Static``2(Microsoft.FSharp.Core.FSharpFunc{System.Object,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a <c>Command</c> binding that depends on the
   <c>CommandParameter</c>
   and can always execute.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.cmdIf.Static``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a <c>Command</c> binding that dispatches the specified message
   and can execute if <paramref name="canExec" /> returns <c>true</c>.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="canExec">Indicates whether the command can execute.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.cmd.Static``2(``0,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a <c>Command</c> binding that dispatches the specified message
   and can always execute.
 </summary>
 <param name="exec">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``3,System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation messages from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``3,System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOptValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value with validation using
   <c>INotifyDataErrorInfo</c>. The binding automatically converts
   between the optional source value and an unwrapped (possibly
   <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation messages from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayValidate.Static``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpResult{``3,System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation message from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayValidate.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding with validation using
   <c>INotifyDataErrorInfo</c>.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="validate">
   Returns the validation messages from the updated model.
 </param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOpt.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpValueOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpValueOption{``1},``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value. The binding
   automatically converts between the optional source value and an
   unwrapped (possibly <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWayOpt.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>
   Creates a two-way binding to an optional value. The binding
   automatically converts between the optional source value and an
   unwrapped (possibly <c>null</c>) value on the view side.
 </summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.Extensions.Binding.twoWay.Static``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit}}})">
 <summary>Creates a two-way binding.</summary>
 <param name="get">Gets the value from the model.</param>
 <param name="set">Returns the message to dispatch.</param>
 <param name="wrapDispatch">
   Wraps the dispatch function with additional behavior, such as
   throttling, debouncing, or limiting.
 </param>
</member>
<member name="M:Elmish.WPF.WindowState.ofVOption``1(Microsoft.FSharp.Core.FSharpValueOption{``0})">
<summary>
 Converts ValueNone to WindowState.Closed, and ValueSome(x) to
 WindowState.Visible(x).
</summary>
</member>
<member name="M:Elmish.WPF.WindowState.ofOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts None to WindowState.Closed, and Some(x) to
 WindowState.Visible(x).
</summary>
</member>
<member name="M:Elmish.WPF.Utils.elmEq``1(``0,``0)">
<summary>
 Memberwise equality where value-typed members and string members are
 compared using structural comparison (the standard F# (=) operator),
 and reference-typed members (except strings) are compared using reference
 equality. This is a useful default for lazy bindings since all parts of the
 Elmish model (i.e., all members of the arguments to this function) are
 normally immutable. For a direct reference equality check (not memberwise),
 see refEq (which should be used when passing a single non-string reference
 type from the model).
</summary>
</member>
<member name="M:Elmish.WPF.Utils.refEq``1">
<summary>
 Reference/physical equality for reference types. Alias for
 LanguagePrimitives.PhysicalEquality. Also see elmEq.
</summary>
</member>
<member name="M:Elmish.WPF.ViewModel.designInstance``2(``0,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``0,``1}})">
<summary>
 Creates a design-time view model using the given model and bindings.
</summary>
</member>
<member name="M:Elmish.WPF.Cmd.showWindow``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Returns a command to display the window returned by the specified
 function. The function can for example be a simple window constructor,
 or a function that instantiates and configures the window (setting owner etc.)
 The window&apos;s DataContext will be set to the same as the main window.
</summary>
</member>
<member name="M:Elmish.WPF.Program.withDebugTrace``4(Elmish.Program{``0,``1,``2,``3})">
<summary>
 Traces all updates using System.Diagnostics.Debug.WriteLine.
</summary>
</member>
<member name="M:Elmish.WPF.Program.mkProgramWpfWithCmdMsg``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{``1}}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{``1}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``0,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit}}})">
<summary>
 Same as mkProgramWpf, except that init and update doesn&apos;t return Cmd&lt;&apos;msg&gt;
 directly, but instead return a CmdMsg discriminated union that is converted
 to Cmd&lt;&apos;msg&gt; using toCmd. This means that the init and update functions
 return only data, and thus are easier to unit test. The CmdMsg pattern is
 general; this is just a trivial convenience function that automatically
 converts CmdMsg to Cmd&lt;&apos;msg&gt; for you in init and update
</summary>
</member>
<member name="M:Elmish.WPF.Program.mkProgramWpf``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit}}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit}}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``0,``1}}})">
<summary>
 Same as mkProgram, but with a signature adapted for Elmish.WPF.
</summary>
</member>
<member name="M:Elmish.WPF.Program.mkSimpleWpf``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``0,``1}}})">
<summary>
 Same as mkSimple, but with a signature adapted for Elmish.WPF.
</summary>
</member>
<member name="M:Elmish.WPF.Program.runWindow``2(System.Windows.Window,Elmish.Program{Microsoft.FSharp.Core.Unit,``0,``1,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``0,``1}}})">
<summary>
 Starts the Elmish and WPF dispatch loops. Will instantiate Application and set its
 MainWindow if it is not already running, and then run the specified window. This is a
 blocking function. If you are using App.xaml as an implicit entry point, see
 startElmishLoop.
</summary>
</member>
<member name="M:Elmish.WPF.Program.runWindowWithConfig``2(Elmish.WPF.ElmConfig,System.Windows.Window,Elmish.Program{Microsoft.FSharp.Core.Unit,``0,``1,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``0,``1}}})">
<summary>
 Starts the Elmish and WPF dispatch loops with the specified configuration. Will
 instantiate Application and set its MainWindow if it is not already running, and then
 run the specified window. This is a blocking function. If you are using App.xaml as an
 implicit entry point, see startElmishLoop.
</summary>
</member>
<member name="M:Elmish.WPF.Program.initializeApplication(System.Windows.Window)">
<summary>
 Instantiates Application and sets its MainWindow if it is not already
 running.
</summary>
</member>
<member name="M:Elmish.WPF.Program.startElmishLoop``2(Elmish.WPF.ElmConfig,System.Windows.FrameworkElement,Elmish.Program{Microsoft.FSharp.Core.Unit,``0,``1,Microsoft.FSharp.Collections.FSharpList{Elmish.WPF.Binding{``0,``1}}})">
<summary>
 Starts an Elmish dispatch loop, setting the bindings as the DataContext for the
 specified FrameworkElement. Non-blocking. If you have an explicit entry point where
 you control app/window instantiation, runWindowWithConfig might be a better option.
</summary>
</member>
</members>
</doc>
